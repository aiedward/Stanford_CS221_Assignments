<head>
  <title>From Language to Logic</title>
  <script src="plugins/main.js"></script>
  <script src="grader-auto.js"></script>
  <script src="grader-manual.js"></script>
</head>

<body onload="onLoad('logic', 'Dylan Moore', 1)">

<div id="assignmentHeader"></div>

<p>
In this assignment, you will get some hands-on experience with logic.
You'll see how logic can be used to represent the meaning of natural language sentences,
and how it can be used to solve puzzles and prove theorems.
Most of this assignment will be translating English into logical formulas,
but in Problem 4, we will delve into the mechanics of logical inference.
</p>

<p>
To get started, launch a Python shell and try typing the following commands to
add logical expressions into the knowledge base.
</p>

<pre>
from logic import *
Rain = Atom('Rain')           # Shortcut
Wet = Atom('Wet')             # Shortcut
kb = createResolutionKB()     # Create the knowledge base
kb.ask(Wet)                   # Prints "I don't know."
kb.ask(Not(Wet))              # Prints "I don't know."
kb.tell(Implies(Rain, Wet))   # Prints "I learned something."
kb.ask(Wet)                   # Prints "I don't know."
kb.tell(Rain)                 # Prints "I learned something."
kb.tell(Wet)                  # Prints "I already knew that."
kb.ask(Wet)                   # Prints "Yes."
kb.ask(Not(Wet))              # Prints "No."
kb.tell(Not(Wet))             # Prints "I don't buy that."
</pre>

To print out the contents of the knowledge base, you can call <code>kb.dump()</code>.
For the example above, you get:
<pre>
==== Knowledge base [3 derivations] ===
* Or(Not(Rain),Wet)
* Rain
- Wet
</pre>
In the output, '*' means the fact was explicitly added by the user, and '-'
means that it was inferred.

Here is a table that describes how logical formulas are represented in code.
Use it as a reference guide:
<p>
<table>
  <tr><td><b>Name</b></td><td><b>Mathematical notation</b></td><td><b>Code</b></td></tr>
  <tr>
    <td>Constant symbol</td>
    <td>$\text{stanford}$</td>
    <td><code>Constant('stanford')</code> (must be lowercase)</td>
  <tr>
    <td>Variable symbol</td>
    <td>$x$</td>
    <td><code>Variable('$x')</code> (must be lowercase)</td>
  <tr>
    <td>Atomic formula (atom)</td>
    <td>$\text{Rain}$<br><br>$\text{LocatedIn}(\text{stanford}, x)$</td>
    <td><code>Atom('Rain')</code> (predicate must be uppercase)<br><br><code>Atom('LocatedIn', 'stanford', '$x')</code> (arguments are symbols)</td>
  </tr>
  <tr>
    <td>Negation</td>
    <td>$\neg \text{Rain}$</td>
    <td><code>Not(Atom('Rain'))</code></td>
  </tr>
  <tr>
    <td>Conjunction</td>
    <td>$\text{Rain} \wedge \text{Snow}$</td>
    <td><code>And(Atom('Rain'), Atom('Snow'))</code></td>
  </tr>
  <tr>
    <td>Disjunction</td>
    <td>$\text{Rain} \vee \text{Snow}$</td>
    <td><code>Or(Atom('Rain'), Atom('Snow'))</code></td>
  </tr>
  <tr>
    <td>Implication</td>
    <td>$\text{Rain} \to \text{Wet}$</td>
    <td><code>Implies(Atom('Rain'), Atom('Wet'))</code></td>
  </tr>
  <tr>
    <td>Equivalence</td>
    <td>$\text{Rain} \leftrightarrow \text{Wet}$ (syntactic sugar for $\text{Rain} \to \text{Wet} \wedge \text{Wet} \to \text{Rain}$)</td>
    <td><code>Equiv(Atom('Rain'), Atom('Wet'))</code></td>
  </tr>
  <tr>
    <td>Existential quantification</td>
    <td>$\exists x . \text{LocatedIn}(\text{stanford}, x)$</td>
    <td><code>Exists('$x', Atom('LocatedIn', 'stanford', '$x'))</code></td>
  </tr>
  <tr>
    <td>Universal quantification</td>
    <td>$\forall x . \text{MadeOfAtoms}(x)$</td>
    <td><code>Forall('$x', Atom('MadeOfAtoms', '$x'))</code></td>
  </tr>
</table>
</li>
</p>

<p>
The operations <code>And</code> and <code>Or</code> only take two arguments.
If we want to take a conjunction or disjunction of more than two, use <code>AndList</code> and <code>OrList</code>.
For example:
<code>AndList([Atom('A'), Atom('B'), Atom('C')])</code> is equivalent to <code>And(And(Atom('A'), Atom('B')), Atom('C'))</code>.
</p>

<!------------------------------------------------------------>
<div class="problemTitle">Problem 1: Propositional logic</div>

<p>
Write a propositional logic formula for each of the following English
sentences in the given function in <code>submission.py</code>.
For example, if the sentence is <i>"If it is raining, it is wet,"</i>
then you would write <code>Implies(Atom('Rain'), Atom('Wet'))</code>, which
would be $\text{Rain} \to \text{Wet}$ in symbols (see <code>examples.py</code>).
Note: Don't forget to return the constructed formula!
</p>

<ol class="problem">
<li class="code" id="1a">
  <i>"If it's summer and we're in California, then it doesn't rain."</i></li>
<li class="code" id="1b">
  <i>"It's wet if and only if it is raining or the sprinklers are on."</i></li>
<li class="code" id="1c">
  <i>"Either it's day or night (but not both)."</i></li>
</ol>

<p>
You can run the following command to test each formula:
<pre>
python grader.py 1a
</pre>
If your formula is wrong, then the grader will provide a counterexample, which
is a model that your formula and the correct formula don't agree on.
For example, if you accidentally wrote <code>And(Atom('Rain'), Atom('Wet'))</code>
for <i>"If it is raining, it is wet,"</i>, then the grader would output the
following:
<pre>
Your formula (And(Rain,Wet)) says the following model is FALSE, but it should be TRUE:
* Rain = False
* Wet = True
* (other atoms if any) = False
</pre>
In this model, it's not raining and it is wet, which satisfies the correct formula $\text{Rain} \to \text{Wet}$ (TRUE),
but does not satisfy the incorrect formula $\text{Rain} \wedge \text{Wet}$ (FALSE).
Use these counterexamples to guide you in the rest of the assignment.
</p>

<!------------------------------------------------------------>
<div class="problemTitle">Problem 2: First-order logic</div>

<p>
Write a first-order logic formula for each of the following English
sentences in the given function in <code>submission.py</code>.
For example, if the sentence is <i>"There is a light that shines,"</i>
then you would write <code>Exists('$x', And(Atom('Light', '$x'), Atom('Shines', '$x')))</code>,
which would be $\exists x . \text{Light}(x) \wedge \text{Shines}(x)$ in
symbols (see <code>examples.py</code>).
</p>

<p>
<i>Tip</i>: Python tuples can span multiple lines, which help with readability
when you are writing logic expressions (some of them in this homework can get quite large)
<p>

<ol class="problem">
<li class="code" id="2a">
  <i>"Every person has a mother."</i></li>
<li class="code" id="2b">
  <i>"At least one person has no children."</i></li>
<li class="code" id="2c">
  Create a formula which defines <code>Daughter(x,y)</code> in terms of <code>Female(x)</code> and <code>Child(x,y)</code>.
<li class="code" id="2d">
  Create a formula which defines <code>Grandmother(x,y)</code> in terms of <code>Female(x)</code> and <code>Parent(x,y)</code>.
</ol>

<!------------------------------------------------------------>
<div class="problemTitle">Problem 3: Liar puzzle</div>

<p>
Someone crashed the server, and accusations are flying.  For this problem, we
will encode the evidence in first-order logic formulas to find out who crashed
the server.
You've narrowed it down to four suspects: John, Susan, Mark, and Nicole.
You have the following information:
<ul>
   <li> John says: "It wasn't me!" </li>
   <li> Susan says: "It was Nicole!" </li>
   <li> Mark says: "No, it was Susan!" </li>
   <li> Nicole says: "Susan's a liar." </li>
   <li> You know that exactly one person is telling the truth. </li>
   <li> You also know exactly one person crashed the server. </li>
</ul>
</p>

<ol class="problem">
  <li class="code" id="3a">
    Fill out <code>liar()</code> to return a list of 6 formulas, one for each of the above facts. Be sure your formulas are exactly in the order specified.
  </li>
</ol>

You can test your code using the following commands:

<pre>
python grader.py 3a-0
python grader.py 3a-1
python grader.py 3a-2
python grader.py 3a-3
python grader.py 3a-4
python grader.py 3a-5
python grader.py 3a-all  # Tests the conjunction of all the formulas
</pre>

To solve the puzzle and find the answer, <code>tell</code> the formulas to the knowledge base and
<code>ask</code> the query <code>CrashedServer('$x')</code>, by running:
<pre>
python grader.py 3a-run
</pre>

<!------------------------------------------------------------>
<div class="problemTitle">Problem 4: Logical Inference</div>

<p>
Having obtained some intuition on how to construct formulas,
we will now perform logical inference to derive new formulas from old ones.
Recall that:
<ul>
    <li>Modus ponens asserts that if we have two formulas, $A \to B$ and $A$ in our knowledge base, then we can derive $B$.
    <li>Resolution asserts that if we have two formulas, $A \vee B$ and $\neg B \vee C$ in our knowledge base, then we can derive $A \vee C$.
    <li>If $A \wedge B$ is in the knowledge base, then we can derive both $A$ and $B$.
</ul>
</p>

<ol class="problem">

  <li class="writeup" id="4a">
  Some inferences that might look like they're
  outside the scope of Modus ponens are actually within reach.
  Suppose the knowledge base contains the following two formulas:
  $$\text{KB} = \{ (A \vee B) \to C, A  \}.$$

  <b>Your task: </b> First, convert the knowledge base into conjunctive normal form (CNF). Then apply Modus ponens to derive C. 
  Please show how your knowledge base changes as you apply derivation rules.
  <p>
  <i>Hint:</i> You may use the fact that $P \to Q$ is equivalent $\neg P \vee Q$.
  <p>
  Remember, this isn't about you as a human being able to arrive at the conclusion, but rather
  about the rote application of a small set of transformations (which a computer could
  execute). 
  <div class="solution">
    First, let us convert the knowledge base into CNF:
    \begin{align}
  \text{KB} &= \{ (A \vee B) \to C, A  \} \\
  &= \{ \neg(A \vee B) \vee C, A  \} \\
  &= \{ (\neg A \wedge \neg B) \vee C, A  \} \\
  &= \{ (\neg A \vee C) \wedge (\neg B \vee C), A  \} \\
  &= \{ (\neg A \vee C), (\neg B \vee C), A  \} \\
  \end{align}
  Next, we apply the rule to convert negation/disjunction into implication:
  $$\text{KB} = \{ A \to C, B \to C, A  \}.$$
  Finally, we apply Modus ponens to $A \to C$ and $A$ to get $C$.
  </div>
  </li>

  <li class="writeup" id="4b">
  Recall that Modus ponens is not complete, meaning that we can't use it to derive everything that's true.
  Suppose the knowledge base contains the following formulas:
  $$\text{KB} = \{ A \vee B, B \to C, (A \vee C) \to D \}.$$
  In this example, Modus ponens cannot be used to derive $D$, even though
  $D$ is entailed by the knowledge base. However, recall that the resolution rule is complete.
  <p/>
  <b>Your task: </b>
  Convert the knowledge base into CNF and apply the resolution rule repeatedly
  to derive $D$.

  <div class="solution">
  First, we convert the knowledge base into CNF:
  $$\text{KB} = \{ A \vee B, \neg B \vee C, \neg A \vee D, \neg C \vee D \}.$$
  Then we apply resolution twice:
  $$\frac{A \vee B, \quad \neg B \vee C}{A \vee C}, \frac{A \vee C, \quad \neg C \vee D}{A \vee D}, \frac{A \vee D, \quad \neg A \vee D}{D}.$$
  This yields $D$, as desired.
  </div>
  </li>
</ol>
</p>

<!------------------------------------------------------------>
<div class="problemTitle">Problem 5: Odd and even integers</div>

<p>
In this problem, we will see how to use logic to automatically prove
mathematical theorems.  We will focus on encoding the theorem and leave the
proving part to the logical inference algorithm.
Here is the theorem:
</p>
If the following constraints hold:
<ul>
   <li> Each number $x$ has exactly one successor, which is not equal to $x$. </li>
   <li> Each number is either odd or even, but not both. </li>
   <li> The successor of an even number is odd. </li>
   <li> The successor of an odd number is even. </li>
   <li> For every number $x$, the successor of $x$ is larger than $x$. </li>
   <li> Larger is a transitive property: if $x$ is larger than $y$ and $y$ is
        larger than $z$, then $x$ is larger than $z$. </li>
</ul>
Then we have the following consequence:
<ul>
  <li>For each number, there is an even number larger than it.</li>
</ul>

<p>Note: in this problem, "larger than" is just an arbitrary relation,
and you should not assume it has any prior meaning.  In other words,
don't assume things like "a number can't be larger than itself" unless explicitly stated.
</p>

<ol class="problem">
   <li class="code" id="5a">
     Fill out <code>ints()</code> to construct 6 formulas for
     each of the constraints.  The consequence has been filled out for you
     (<code>query</code> in the code).
You can test your code using the following commands:
<pre>
python grader.py 5a-0
python grader.py 5a-1
python grader.py 5a-2
python grader.py 5a-3
python grader.py 5a-4
python grader.py 5a-5
python grader.py 5a-all  # Tests the conjunction of all the formulas
</pre>

To finally prove the theorem, <code>tell</code> the formulas to the knowledge base and
<code>ask</code> the query by running model checking (on a finite model):
<pre>
python grader.py 5a-run
</pre>
</li>

<li class="writeup" id="5b">
Suppose we added another constraint:
<ul>
  <li> A number is not larger than itself. </li>
</ul>
Prove that there is no finite, non-empty model for which the resulting set of 7
constraints is consistent.

This means that if we try to prove this theorem by model checking only finite models,
we will find that it is false, when in fact the theorem is true for a countably infinite model
(where the objects in the model are the numbers).
<div class="solution">
Consider a finite model with $n$ elements $X$.  We will show by contradiction
that this model can't possibly satisfy all the constraints.
<p>
Take any number $x_0 \in X$.
constraint 1 says that $x_0$ has a unique successor (call it $x_1$) not equal to $x$;
from constraint 5, we infer that $x_1$ is larger than $x_0$.
Continuing, we obtain a sequence of numbers $x_0, \dots, x_n$
such that each $x_{i+1}$ is larger than $x_i$.
<p>
We now have a length $n+1$ sequence in a domain of size $|X| = n$, so there must exist
two elements with $x_i = x_j$ but $i &lt; j$.
By constraint 6 (transitivity), we also have that $x_j$ is larger than $x_i$.
But this contradicts constraint 7 (a number cannot be larger than itself).
<p>
This result holds for all finite $n$,
so no finite model can satisfy all 7 constraints.
While it may be "obvious" that a number can't be "larger" than itself,
without constraint 7, cycles are possible (i.e., $x &gt; y &gt; ... &gt; x$, and by
transitivity, $x &gt; x$).
</div>

</li>

</ol>

<!------------------------------------------------------------>
<div class="problemTitle">Problem 6: Semantic parsing (extra credit)</div>

<p>
Semantic parsing is the task of converting natural lanugage utterances into first-order logic formulas.
We have created a small set of grammar rules in the code for you in
<code>createBaseEnglishGrammar()</code>.
In this problem, you will add additional grammar rules to handle a wider variety of sentences.
Specifically, create a <code>GrammarRule</code> for each of the following sentence structures.

<ol class="problem">
  <li class="code" id="6a">
    Example: <i>Every person likes some cat.</i>
    General template: <pre>$Clause &larr; every $Noun $Verb some $Noun</pre>
  </li>
  <li class="code" id="6b">
    Example: <i>There is some cat that every person likes.</i>
    General template: <pre>$Clause &larr; there is some $Noun that every $Noun $Verb</pre>
  </li>
  <li class="code" id="6c">
    Example: <i>If a person likes a cat then the former feeds the latter.</i>
    General template: <pre>$Clause &larr; if a $Noun $Verb a $Noun then the former $Verb the latter</pre>
  </li>
</ol>

After implementing these functions, you should be able to try some simple queries using <code>nli.py</code>!
For example:
<pre>
$ python nli.py

&gt Every person likes some cat.

&gt&gt&gt&gt&gt I learned something.
------------------------------
&gt Every cat is a mammal.

&gt&gt&gt&gt&gt I learned something.
------------------------------
&gt Every person likes some mammal?

&gt&gt&gt&gt&gt Yes.
</pre>

</body>
